#pragma config(Sensor, S1, touchSensor, sensorEV3_Touch)
#pragma config(Sensor, S2, gyroSensor, sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S3, colorSensor, sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4, sonarSensor, sensorEV3_Ultrasonic)
#pragma config(Motor, motorA, armMotor, tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor, motorB, leftMotor, tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor, motorC, rightMotor, tmotorEV3_Large, PIDControl, driveRight, encoder)
#pragma config(StandardModel, "EV3_REMBOT")
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define circumfrance 17.27
void drive(long nMotorRatio, long dist, long power);
void turn90(long nMotorRatio, long power);



task main()
{
	//calling function drive()
	drive(0, 50, 50);
	//calling function turn90()
	turn90(100, 50);


}

//function drive() calculates full rotation by multiplying 360 by the distance divided by the circumfrance
void drive(long nMotorRatio, long dist, long power)
{
	float rotations = 360 * (dist/circumfrance);

	resetMotorEncoder(motorC);
	resetMotorEncoder(motorB);

	setMotorSyncEncoder(motorC, motorB, nMotorRatio, rotations, power);

	waitUntilMotorStop(motorB);
}

//function turn90() resets motorencoder then turns 90 degrees
void turn90(long nMotorRatio, long power)
{

	resetMotorEncoder(motorC);
	resetMotorEncoder(motorB);

	setMotorSyncEncoder(motorC, motorB, nMotorRatio, 170, power);

	waitUntilMotorStop(motorB);


}
