#pragma config(Sensor, S1,     colourSensor,   sensorEV3_Color)
#pragma config(Sensor, S2,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Sensor, S3,     gyroSensor,     sensorEV3_Gyro)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//we used this circumfrance from our old code
#define circ 17.6

//functions to execute square
void turn90();
int chooseDistance();
void square(int distance);
void reset();
void forward(int distance, int powerr);

task main()
{
	//calling choosedistance function and placing the value in int distance
	int distance = chooseDistance();

	//passing int distance to function square
	square(distance);
}



//we used this buttonpress code from previous code
int chooseDistance()
{
	int distance = 0;

	while(getButtonPress(buttonEnter)==0)
	{
		displayBigTextLine(4, "%d centimeters", distance);

		if(getButtonPress(buttonUp))
		{
			distance = 40;
		}
		else if(getButtonPress(buttonDown))
		{
			distance = 60;
		}
		else if(getButtonPress(buttonLeft))
		{
			distance = 70;
		}
		else if(getButtonPress(buttonRight))
		{
			distance = 80;
		}

	}

	return distance;
}

//this function resets the motors to get an accurate square
void reset()
{
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);
}

//this function has a loop that calls turn90 function 4 times
void square(int distance)
{
	int i = 0;

	for(i=0;i<4;i++)
	{
		forward(distance,30);

		turn90();
	}
}

//using the gyro to get an accurate 90 degree turn
void turn90()
{

	resetGyro(gyroSensor);

	while(SensorValue(gyroSensor) < 83)
	{
		setMotorSync(leftMotor, rightMotor, 100, 23);
  }
}

//this is our calculating distance code from our previous programme
void forward(int distance, int powerr)
{
	float rotations = 360 * (distance/circ);

	reset();
	setMotorSyncEncoder(leftMotor, rightMotor, 0, rotations, 30);
	waitUntilMotorStop(leftMotor);
}
