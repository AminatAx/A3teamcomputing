#pragma config(Sensor, S1,     colourSensor,   sensorEV3_Color)
#pragma config(Sensor, S2,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Sensor, S3,     gyroSensor,     sensorEV3_Gyro)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define circ 17.6

//functions to execute triangle
void turn115();
int chooseDistance();
void triangle(int distance);
void reset();
void forward(int distance, int powerr);

task main()
{
	//calling the choosedistance function and placing the return distance in int return
	int distance = chooseDistance();

	//calling the square function and passing int distance to function triangle
	triangle(distance);
}



//this choosedistance function is from our previous programme
int chooseDistance()
{
	int distance = 0;

	while(getButtonPress(buttonEnter)==0)
	{
		displayBigTextLine(4, "%d centimeters", distance);

		if(getButtonPress(buttonUp))
		{
			distance = 40;
		}
		else if(getButtonPress(buttonDown))
		{
			distance = 60;
		}
		else if(getButtonPress(buttonLeft))
		{
			distance = 70;
		}
		else if(getButtonPress(buttonRight))
		{
			distance = 80;
		}

	}

	return distance;
}

//reset function resets the motors to get an accurate triangle
void reset()
{
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);
}

//function triangle calls turn115 function in a loop of 3
void triangle(int distance)
{
	int i = 0;

	for(i=0;i<3;i++)
	{
		forward(distance,30);

		turn115();
	}
}

//turn 115 executes a 115 degree turn
void turn115()
{
	resetGyro(gyroSensor);

	while(SensorValue(gyroSensor) < 115)
	{
		waitUntil(100);
		setMotorSync(leftMotor, rightMotor, 100, 20);
  }
}

//this forward function is from our previous code
void forward(int distance, int powerr)
{
	float rotations = 360 * (distance/circ);

	reset();
	setMotorSyncEncoder(leftMotor, rightMotor, 0, rotations, 30);
	waitUntilMotorStop(leftMotor);
}
